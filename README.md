# Hotkeyz

A small (3.3kB min / 1.6kB gzip) dev-friendly keyboard event listener.

## Installation

`npm install hotkeyz`

## Building the listener

The `hotkeyz` function expects a config object as parameter and will return a function that you can use as a keyboard event listener.

The config object lists the different combos you'd like to react to, they should use valid combos as keys and event callbacks as value.

Combos are composed of modifiers and actual keys and should respect the following rules:

- simple key: `{key}`
- modifier: `{modifier} - {key}`
- many modifiers: `{modifier} + {modifier} [+ ...] - {key}`
- many combos: `{combo}, {combo} [, ...]`
- combo sequence (waits up to 1s between each combo): `{combo} {combo} [...]`

Valid modifiers are:

- `meta`
- `ctrl`
- `alt`
- `shift`

```js
import hotkeyz from 'hotkeyz'

const listener = hotkeyz({
  a: () => console.log('Pressed A.'),

  'meta - space': () => console.log('Pressed SPACE while holding META.'),

  'shift + alt + ctrl - esc': () =>
    console.log('Pressed ESCAPE while holding SHIFT, ALT and CTRL.'),

  'x, y': e => console.log('Pressed X or Y.', { key: e.key }),

  'a b c': () => console.log('Pressed A, then B, then C.'),

  'meta - k meta - up': e =>
    console.log(
      'Pressed k while holding META, then up while still holding META'
    )
})
```

## Using the listener

From [keycode](https://github.com/timoxley/keycode) README:

> Due to the keypress event being weird, keycode currently does not support the keypress event, but this should not be an issue as keydown and keyup work perfectly fine.

So you'll only be able to use hotkeyz with those two events.

```js
const listener = hotkeyz({
  a: () => console.log('a')
})

document.addEventListener('keydown', listener)
```

Every key event that has a matching hotkey will be captured by the listener: it won't bubble up and its default action will be prevented. For any other key stroke, the browser will behave as it normally would.

## Key detection

Hotkeys relies on two methods to match your hotkeys with the emitted keyboard event, providing you two ways of describing your hotkeys:

1. based on `event.key`: use the actual character you want your listener to react to
2. based on `event.keyCode`: use the QWERTY based key name

`keyCode` detection is based on [keycode](https://github.com/timoxley/keycode) so you can name your keys using strings that could be generated by this lib.

```js
hotkeys({
  a: () => {}, // event.key === 'a'
  'shift - esc': () => {} // event.keyCode === 65 && event.shiftKey === true
})
```

Note that the `key` based method is preferred and will always be given priority over a matching `keyCode` one, meaning its callback will shadow the other's.

```js
hotkeys({
  'shift - a': () => {}, // event.keyCode === 65 && event.shiftKey === true
  A: () => {}, // event.key === 'A', shadows 'shift - a'

  'shift - /': () => {}, // event.keyCode === 191 && event.shiftKey === true
  '?': () => {} // event.key === '?', shadows 'shift - /'
})
```

When describing a sequence, you should stick to one of the two methods, hotkeyz won't react to a rule with mixed syntaxes.
Again, `key` based sequences have priority over the other kind.

```js
hotkeys({
  'shift - / shift - / shift - /': () => {}, // ok
  '? ? ?': () => {}, // ok + takes over the combo above
  '? shift - / ?': () => {} // mixed => will never be detected
})
```

As the `+`, `-` and `,` characters are reserved words, you cannot use them directly as key in your combos. To still be able to make them a hotkey, the aliases `plus`, `minus` and `comma` can be used.

```js
hotkeys({
  'shift - ,': () => {}, // will throw an error
  'shift - comma': () => {} // use this instead
})
```

## Examples

### React

```js
class Hotkeyz extends React.Component {
  doSomething = () => {
    console.log('something was done')
  }

  listener = hotkeyz({
    esc: this.doSomething
  })

  render() {
    return <div onKeyDown={this.listener} />
  }
}
```
